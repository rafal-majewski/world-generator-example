<script lang="ts">
	import {LoopingNoiseGenerator} from "$lib/noise/LoopingNoiseGenerator.ts";
	import {computeRandomNormalizedNumberDeterministically} from "$lib/random/computeRandomNumberDeterministically.ts";
	import type {RgbColor} from "$lib/RgbColor.ts";
	import type {XyCoordinates} from "$lib/XyCoordinates.ts";
	function mix(color1: RgbColor, color2: RgbColor, ratio: number): RgbColor {
		return {
			red: color1.red * (1 - ratio) + color2.red * ratio,
			green: color1.green * (1 - ratio) + color2.green * ratio,
			blue: color1.blue * (1 - ratio) + color2.blue * ratio,
		};
	}
	class SandLayerGenerator {
		public constructor(color: RgbColor, seed: number) {
			const noiseGenerator = new LoopingNoiseGenerator(
				1,
				(layerIndex) => 1,
				(layerIndex) => 2 * Math.PI * 4,
				(layerIndex) => ({
					x: computeRandomNormalizedNumberDeterministically(seed * 3 + layerIndex),
					y: computeRandomNormalizedNumberDeterministically(seed * 3 + layerIndex + 1),
				}),
				(layerIndex) =>
					computeRandomNormalizedNumberDeterministically(seed * 3 + layerIndex + 2) * 2 * Math.PI,
			);
			this.noiseGenerator = noiseGenerator;
			this.color = color;
		}
		private readonly noiseGenerator: LoopingNoiseGenerator;
		public readonly color: RgbColor;
		public generate(position: XyCoordinates): null | RgbColor {
			const rawValue = this.noiseGenerator.compute(position);
			const value = Math.max(0, rawValue - 0.15);
			if (value > 0) {
				return this.color;
			}
			return null;
		}
	}
	function computeSandColor(
		sandLayerGenerators: readonly SandLayerGenerator[],
		position: XyCoordinates,
	): null | RgbColor {
		for (const sandLayerGenerator of sandLayerGenerators) {
			const color: RgbColor | null = sandLayerGenerator.generate(position);
			if (color !== null) {
				return color;
			}
		}
		return null;
	}
	const yellowColor: RgbColor = {
		red: 206,
		green: 201,
		blue: 182,
	};
	const sandLayerGenerators: readonly SandLayerGenerator[] = [
		new SandLayerGenerator(
			mix(
				{
					red: 219,
					green: 193,
					blue: 166,
				},
				yellowColor,
				0.3,
			),
			0,
		),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 216,
		// 			green: 182,
		// 			blue: 145,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	1,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 212,
		// 			green: 195,
		// 			blue: 165,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	2,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 236,
		// 			green: 218,
		// 			blue: 194,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	3,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 201,
		// 			green: 170,
		// 			blue: 141,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	4,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 254,
		// 			green: 236,
		// 			blue: 216,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	5,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 193,
		// 			green: 167,
		// 			blue: 142,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	6,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 215,
		// 			green: 186,
		// 			blue: 152,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	7,
		// ),
		// new SandLayerGenerator(
		// 	mix(
		// 		{
		// 			red: 200,
		// 			green: 174,
		// 			blue: 141,
		// 		},
		// 		yellowColor,
		// 		0.3,
		// 	),
		// 	8,
		// ),
	];
	function divideColor(color: RgbColor, divisor: number): RgbColor {
		return {
			red: color.red / divisor,
			green: color.green / divisor,
			blue: color.blue / divisor,
		};
	}
	const averageColor: RgbColor = divideColor(
		sandLayerGenerators.reduce<RgbColor>(
			(sum, generator) => ({
				red: sum.red + generator.color.red,
				green: sum.green + generator.color.green,
				blue: sum.blue + generator.color.blue,
			}),
			{red: 0, green: 0, blue: 0},
		),
		sandLayerGenerators.length,
	);
	function handleMount(canvas: HTMLCanvasElement): void {
		const ctx = canvas.getContext("2d");
		if (ctx === null) {
			throw new Error("Failed to get 2D context.");
		}
		const imageData = ctx.createImageData(canvas.width, canvas.height);
		for (let y = 0; y < canvas.height; y += 1) {
			for (let x = 0; x < canvas.width; x += 1) {
				const position: XyCoordinates = {
					x: x / canvas.width,
					y: y / canvas.height,
				};
				const color: RgbColor | null = computeSandColor(sandLayerGenerators, position) ?? {
					red: 0,
					green: 0,
					blue: 0,
				};
				const index = 4 * (y * canvas.width + x);
				imageData.data[index] = color.red;
				imageData.data[index + 1] = color.green;
				imageData.data[index + 2] = color.blue;
				imageData.data[index + 3] = 255;
			}
		}
		ctx.putImageData(imageData, 0, 0);
	}
</script>

<main>
	<canvas use:handleMount width="600" height="600"></canvas>
</main>
